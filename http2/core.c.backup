////////////////////////////////
//~ H2 Session Functions

internal b32
ssl_write_all(SSL *ssl, const u8 *data, u64 size)
{
	for(u64 written = 0; written < size;)
	{
		int result = SSL_write(ssl, data + written, (int)(size - written));
		if(result <= 0)
		{
			return 0;
		}
		written += result;
	}
	return 1;
}

internal H2_Session *
h2_session_alloc(Arena *arena, SSL *ssl, OS_Handle socket, H2_RequestHandler handler, void *handler_data)
{
	H2_Session *session = push_array(arena, H2_Session, 1);
	session->arena = arena;
	session->ssl = ssl;
	session->socket = socket;
	session->streams = h2_stream_table_alloc(arena);
	session->request_handler = handler;
	session->request_handler_data = handler_data;

	// Allocate backend connection array
	session->backend_capacity = 32;
	session->backends = push_array(arena, Backend_Connection *, session->backend_capacity);
	session->backend_count = 0;

	nghttp2_session_callbacks *callbacks;
	nghttp2_session_callbacks_new(&callbacks);

	nghttp2_session_callbacks_set_on_begin_headers_callback(callbacks, h2_on_begin_headers_callback);
	nghttp2_session_callbacks_set_on_header_callback(callbacks, h2_on_header_callback);
	nghttp2_session_callbacks_set_on_frame_recv_callback(callbacks, h2_on_frame_recv_callback);
	nghttp2_session_callbacks_set_on_data_chunk_recv_callback(callbacks, h2_on_data_chunk_recv_callback);
	nghttp2_session_callbacks_set_on_stream_close_callback(callbacks, h2_on_stream_close_callback);
	nghttp2_session_callbacks_set_send_callback(callbacks, h2_send_callback);

	nghttp2_session_server_new(&session->ng_session, callbacks, session);
	nghttp2_session_callbacks_del(callbacks);

	return session;
}

internal void
h2_session_send_settings(H2_Session *session)
{
	nghttp2_settings_entry settings[] = {
	    {NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, 100},
	    {NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE, 1048576}, // 1MB per stream
	};

	nghttp2_submit_settings(session->ng_session, NGHTTP2_FLAG_NONE, settings, ArrayCount(settings));
	session->want_write = 1;
}

internal void
h2_session_flush(H2_Session *session)
{
	if(!session->want_write)
	{
		return;
	}

	// Keep flushing until nghttp2 has no more data to send
	for(;;)
	{
		const uint8_t *data = 0;
		ssize_t datalen = nghttp2_session_mem_send(session->ng_session, &data);

		if(datalen > 0)
		{
			ssl_write_all(session->ssl, data, (u64)datalen);
		}
		else
		{
			break;
		}
	}

	session->want_write = 0;
}

internal void
h2_session_release(H2_Session *session)
{
	if(session->ng_session != 0)
	{
		nghttp2_session_del(session->ng_session);
	}
}

////////////////////////////////
//~ H2 Backend Management

internal void
h2_session_add_backend(H2_Session *session, Backend_Connection *backend)
{
	Assert(session->backend_count < session->backend_capacity);
	session->backends[session->backend_count++] = backend;
}

internal void
h2_session_remove_backend(H2_Session *session, u64 index)
{
	Assert(index < session->backend_count);
	// Swap with last and decrement count
	session->backends[index] = session->backends[session->backend_count - 1];
	session->backend_count--;
}

////////////////////////////////
//~ H2 Event Loop

internal void
h2_session_run_event_loop(H2_Session *session)
{
	int client_fd = (int)session->socket.u64[0];
	u64 loop_count = 0;

	for(;;)
	{
		loop_count++;
		if(loop_count % 100 == 0)
		{
			fprintf(stderr, "httpproxy: event loop iteration %llu (backends=%llu)\n", (unsigned long long)loop_count,
			        (unsigned long long)session->backend_count);
			fflush(stderr);
		}

		// Build fd_sets for select()
		fd_set read_fds, write_fds;
		FD_ZERO(&read_fds);
		FD_ZERO(&write_fds);

		int max_fd = client_fd;

		// Always monitor client socket for reads
		FD_SET(client_fd, &read_fds);

		// Monitor backend sockets based on their state
		for(u64 i = 0; i < session->backend_count; i++)
		{
			Backend_Connection *backend = session->backends[i];
			int backend_fd = (int)backend->socket.u64[0];

			if(backend_fd < 0)
			{
				continue;
			}

			switch(backend->state)
			{
				case BACKEND_CONNECTING:
				case BACKEND_SENDING_REQUEST:
					FD_SET(backend_fd, &write_fds);
					max_fd = Max(max_fd, backend_fd);
					break;

				case BACKEND_READING_RESPONSE:
					FD_SET(backend_fd, &read_fds);
					max_fd = Max(max_fd, backend_fd);
					break;

				default:
					break;
			}
		}

		// Adaptive timeout: shorter when active (10ms), longer when idle (1s)
		struct timeval timeout;
		if(session->backend_count > 0)
		{
			timeout.tv_sec = 0;
			timeout.tv_usec = 10000; // 10ms when backends are active
		}
		else
		{
			timeout.tv_sec = 1;
			timeout.tv_usec = 0; // 1s when idle
		}

		int ready = select(max_fd + 1, &read_fds, &write_fds, 0, &timeout);

		if(ready < 0)
		{
			break; // Error
		}

		// Process client socket
		if(FD_ISSET(client_fd, &read_fds))
		{
			u8 buffer[16384];
			ssize_t bytes = SSL_read(session->ssl, buffer, sizeof(buffer));

			if(bytes > 0)
			{
				ssize_t consumed = nghttp2_session_mem_recv(session->ng_session, buffer, (size_t)bytes);
				if(consumed < 0)
				{
					fprintf(stderr, "httpproxy: nghttp2 error: %s\n", nghttp2_strerror((int)consumed));
					fflush(stderr);
					break; // Protocol error
				}
			}
			else
			{
				int ssl_error = SSL_get_error(session->ssl, (int)bytes);
				if(ssl_error == SSL_ERROR_ZERO_RETURN)
				{
					fprintf(stderr, "httpproxy: client closed connection (SSL_ERROR_ZERO_RETURN)\n");
					fflush(stderr);
					break; // Clean shutdown
				}
				else if(ssl_error != SSL_ERROR_WANT_READ)
				{
					fprintf(stderr, "httpproxy: SSL read error: %d\n", ssl_error);
					fflush(stderr);
					break; // Error
				}
			}
		}

		// Process backend sockets
		for(u64 i = 0; i < session->backend_count;)
		{
			Backend_Connection *backend = session->backends[i];
			int backend_fd = (int)backend->socket.u64[0];

			if(backend_fd >= 0)
			{
				if(FD_ISSET(backend_fd, &write_fds))
				{
					backend_handle_write(backend);
				}

				if(FD_ISSET(backend_fd, &read_fds))
				{
					backend_handle_read(backend, session, session->arena);
				}
			}

			// Process completed backends
			if(backend->state == BACKEND_DONE)
			{
				H2_Stream *stream = h2_stream_table_get(session->streams, backend->stream_id);
				if(stream != 0)
				{
					// Parse HTTP response manually (simplified version - assumes HTTP/1.1)
					String8 response_data = {backend->response_buffer, backend->response_size};

					u64 time_done = os_now_microseconds();
					u64 total_us = time_done - backend->time_start;
					u64 connect_us = backend->time_connected - backend->time_start;
					u64 send_us = backend->time_request_sent - backend->time_connected;
					u64 ttfb_us = backend->time_first_byte - backend->time_request_sent;
					u64 download_us = time_done - backend->time_first_byte;

					fprintf(stderr,
					        "httpproxy: backend timing - total=%lluμs (connect=%lluμs send=%lluμs ttfb=%lluμs "
					        "download=%lluμs) size=%lluB\n",
					        (unsigned long long)total_us, (unsigned long long)connect_us, (unsigned long long)send_us,
					        (unsigned long long)ttfb_us, (unsigned long long)download_us,
					        (unsigned long long)backend->response_size);
					fflush(stderr);

					// Find header/body separator
					u64 header_end = str8_find_needle(response_data, 0, str8_lit("\r\n\r\n"), 0);
					if(header_end < response_data.size)
					{
						String8 headers_section = str8_prefix(response_data, header_end);
						String8 raw_body = str8_skip(response_data, header_end + 4);

						// Parse status line
						u64 status_line_end = str8_find_needle(headers_section, 0, str8_lit("\r\n"), 0);
						String8 status_line = str8_prefix(headers_section, status_line_end);

						// Extract status code (e.g., "HTTP/1.1 200 OK")
						u64 first_space = str8_find_needle(status_line, 0, str8_lit(" "), 0);
						String8 after_version = str8_skip(status_line, first_space + 1);
						u64 second_space = str8_find_needle(after_version, 0, str8_lit(" "), 0);
						String8 status_code_str = str8_prefix(after_version, second_space);
						u64 status_code = u64_from_str8(status_code_str, 10);

						HTTP_Response *res = http_response_alloc(stream->arena, (HTTP_Status)status_code);

						// Parse headers
						b32 is_chunked = 0;
						String8 headers_only = str8_skip(headers_section, status_line_end + 2);
						String8 remaining = headers_only;
						while(remaining.size > 0)
						{
							u64 line_end = str8_find_needle(remaining, 0, str8_lit("\r\n"), 0);
							String8 header_line = (line_end >= remaining.size) ? remaining : str8_prefix(remaining, line_end);
							remaining = (line_end >= remaining.size) ? str8_zero() : str8_skip(remaining, line_end + 2);

							if(header_line.size == 0)
							{
								break;
							}

							u64 colon = str8_find_needle(header_line, 0, str8_lit(":"), 0);
							if(colon < header_line.size)
							{
								String8 name = str8_prefix(header_line, colon);
								String8 value = str8_skip(header_line, colon + 1);

								// Trim leading whitespace from value
								while(value.size > 0 && (value.str[0] == ' ' || value.str[0] == '\t'))
								{
									value = str8_skip(value, 1);
								}

								// Check for chunked transfer encoding
								if(str8_match(name, str8_lit("Transfer-Encoding"), StringMatchFlag_CaseInsensitive) &&
								   str8_match(value, str8_lit("chunked"), StringMatchFlag_CaseInsensitive))
								{
									is_chunked = 1;
									// Don't add Transfer-Encoding to headers (HTTP/2 doesn't use it)
								}
								else
								{
									// Rewrite relative Location headers (e.g., "web/" -> "/jellyfin/web/")
									if(str8_match(name, str8_lit("Location"), StringMatchFlag_CaseInsensitive) && value.size > 0 &&
									   value.str[0] != '/' &&
									   !str8_match(str8_prefix(value, 4), str8_lit("http"), StringMatchFlag_CaseInsensitive))
									{
										value = str8f(stream->arena, "%S/%S", backend->path_prefix, value);
									}

									http_header_add(stream->arena, &res->headers, name, value);
								}
							}
						}

						// Decode chunked body if needed
						String8 body = raw_body;
						if(is_chunked)
						{
							// Parse chunked encoding and extract actual data
							u8 *decoded = push_array(stream->arena, u8, raw_body.size);
							u64 decoded_size = 0;
							String8 chunk_remaining = raw_body;

							while(chunk_remaining.size > 0)
							{
								// Read chunk size (hex number followed by \r\n)
								u64 chunk_size_end = str8_find_needle(chunk_remaining, 0, str8_lit("\r\n"), 0);
								if(chunk_size_end >= chunk_remaining.size)
								{
									break;
								}

								String8 chunk_size_str = str8_prefix(chunk_remaining, chunk_size_end);
								u64 chunk_size = 0;

								// Parse hex
								for(u64 i = 0; i < chunk_size_str.size; i++)
								{
									u8 c = chunk_size_str.str[i];
									if(c >= '0' && c <= '9')
									{
										chunk_size = (chunk_size << 4) | (c - '0');
									}
									else if(c >= 'a' && c <= 'f')
									{
										chunk_size = (chunk_size << 4) | (c - 'a' + 10);
									}
									else if(c >= 'A' && c <= 'F')
									{
										chunk_size = (chunk_size << 4) | (c - 'A' + 10);
									}
									else
									{
										break; // Stop at semicolon or other non-hex char
									}
								}

								if(chunk_size == 0)
								{
									break; // Last chunk
								}

								// Skip chunk size line
								chunk_remaining = str8_skip(chunk_remaining, chunk_size_end + 2);

								// Copy chunk data
								if(chunk_size <= chunk_remaining.size)
								{
									MemoryCopy(decoded + decoded_size, chunk_remaining.str, chunk_size);
									decoded_size += chunk_size;
									chunk_remaining = str8_skip(chunk_remaining, chunk_size + 2); // +2 for trailing \r\n
								}
								else
								{
									break;
								}
							}

							body = (String8){decoded, decoded_size};
							fprintf(stderr, "httpproxy: decoded chunked body from %llu to %llu bytes\n",
							        (unsigned long long)raw_body.size, (unsigned long long)body.size);
							fflush(stderr);
						}

						res->body = body;
						stream->response = res;

						fprintf(stderr, "httpproxy: parsed response - status=%llu, headers=%llu, body_size=%llu\n",
						        (unsigned long long)status_code, (unsigned long long)res->headers.count,
						        (unsigned long long)body.size);

						// Dump headers for debugging
						for(u64 h = 0; h < res->headers.count; h++)
						{
							fprintf(stderr, "  %.*s: %.*s\n", (int)res->headers.headers[h].name.size,
							        res->headers.headers[h].name.str, (int)res->headers.headers[h].value.size,
							        res->headers.headers[h].value.str);
						}
						fflush(stderr);

						h2_stream_send_response(session, stream);
					}
				}

				// Close socket and remove from array
				os_file_close(backend->socket);
				h2_session_remove_backend(session, i);
				continue; // Don't increment i
			}
			else if(backend->state == BACKEND_ERROR)
			{
				// Send error response
				H2_Stream *stream = h2_stream_table_get(session->streams, backend->stream_id);
				if(stream != 0)
				{
					HTTP_Response *err_res = http_response_alloc(stream->arena, HTTP_Status_502_BadGateway);
					http_header_add(stream->arena, &err_res->headers, str8_lit("Content-Type"), str8_lit("text/plain"));
					err_res->body = str8_lit("Backend error");
					stream->response = err_res;
					h2_stream_send_response(session, stream);
				}

				// Close socket and remove from array
				if(!os_handle_match(backend->socket, os_handle_zero()))
				{
					os_file_close(backend->socket);
				}
				h2_session_remove_backend(session, i);
				continue; // Don't increment i
			}

			i++; // Only increment if we didn't remove
		}

		// Flush any pending nghttp2 writes
		h2_session_flush(session);
	}
}
